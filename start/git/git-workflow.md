---
description: >-
  Тут розглянемо основні підходи до ведення розробки із використанням системи
  контролю версій, які можуть використовуватися різними командами залежно від
  методологій
---

# Git Workflow

## Better Repository Organization, Faster Development&#x20;

Документація [Cloud Architecture Center](https://cloud.google.com/architecture/devops/devops-tech-trunk-based-development) наводить приклад, що існує два основні шаблони для спільної роботи команд розробників за допомогою контролю версій. Один з них полягає у використанні _**feature-branches**_, де розробник або група розробників створюють гілку, як правило, із основної гілки (_**trunck -**_ також відомого як _**main**_ або _**mainline**_), а потім ізольовано працюють над цією гілкою, доки функція, яку вони створюють, не буде завершена. Коли команда вважає, що функція готова до роботи, вони об’єднують гілку функції назад у trunck.

Другий шаблон відомий як _**trunk-based development (магістральна розробка)**_, коли кожен розробник ділить свою роботу на невеликі партії та об’єднує цю роботу в trunck принаймні один раз (і потенційно кілька разів) на день. Ключовою відмінністю між цими підходами є обсяг.&#x20;

Розгалуження гілок  для функцій зазвичай залучає кількох розробників і займає дні або навіть тижні роботи. Розгалуження в магістральній розробці зазвичай тривають не більше кількох годин, причому багато розробників часто об’єднують свої окремі зміни в магістральну.

## Feature And Develop Branches

Це, мабуть, найтиповіший підхід, який використовує більшість команд і описаний у безлічі статтей. Він чудово пояснений у [A successful Git branching model](https://nvie.com/posts/a-successful-git-branching-model/) та [How To Structure Your Git Branching Strategy](https://towardsdatascience.com/how-to-structure-your-git-branching-strategy-by-a-data-engineer-45ff96857bb). Схематично це представлено на рисунку нижче:&#x20;

<figure><img src="../../.gitbook/assets/image (8).png" alt=""><figcaption><p>Git-workflow за функціональним принципом</p></figcaption></figure>

Фактично у production іде код, який знаходиться у гілці master із відповідними тегами, що відображають релізи.  Так як цей код працює на стороні клієнта у product environment, тому може виникати необхідність у виправленні поточних багів, що здійснюється у гілках hotfixes, які створюються із гілки master.&#x20;

Основна сутність жеж розробки полягає саме у тому, що команда розробників, яка працює над певним релізом постній працює із гілкою _**dev**_. Саме з неї робляться гілки для реалізації поточних необхідни функціональностей.&#x20;

У випадку передрелізної підготовки створюється нова гілка _**release**_ АБО _**staging**_. Яка розгортається на відповідному тестовому середовищі та на ній виконуються роботи виключно по тестуванню та вирішення багів. По закінченню релізу результати роботи об'єднуються із гілками _**master**_ та _**dev**_.

Слід зауважити, що дана методологія розробки добре поєднуєтсья із рекомендаціями [Microsoft Team Data Science Process по process execution](https://github.com/Azure/Microsoft-TDSP/blob/master/Docs/project-execution.md). Тут варто лише зробити ремарку, що відповідно під кожну функціональність, робота над якою виконуються відповідно до поставленого завдання у DevOps (Jira etc) створюється гілка, яка закріплюється у related. А сам процес розробки доволі стандартний.

<figure><img src="../../.gitbook/assets/image (16).png" alt=""><figcaption><p>Типове планування роботи під час спринта, що включає розробку та контроль версій для DS проектів </p></figcaption></figure>

## Trunk Based Development

Для глибокого розуміння даного підходу варто ознайомитися із статтями [Patterns for Managing Source Code Branches](https://martinfowler.com/articles/branching-patterns.html#release-branch) та цілу документацію по методології [Trunck Based Development](https://trunkbaseddevelopment.com/branch-for-release/), яка наголошує на тому, що попередній підхід існує в ідеальному світі, а об'єднувати зміни (мерджити) доволі складно у результаті, адже чим довше розробники  працюють у своїх гілках, тим більше вони відрізняються з часом.

<figure><img src="../../.gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

_**Trunck**_ розробка близька до командного програмування — це швидкі ітерації головної гілки, щоб швидко випустити життєздатний продукт. Команда створює короткострокові розгалуження функцій, які зазвичай тривають не більше кількох днів і часто передаються безпосередньо до _**master**_ гілки.

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

Його називають _**trunck (стовбур)**_, тому що дана методологія робить головну гілку найактивнішою та найкориснішою у всьому репозиторії, як товстий стовбур дерева, який підтримує все інше. Уся розробка зосереджена на цій гілці, яку швидко та легко охопити, що забезпечує гарний досвід розробки. Після готовності до випуску для кожного релізу створюється нова версія релізу. Це допомогає зберігати релізи окремо від основних гілок, а також допомагає додавати або вибирати виправлення до випусків LTS (long-term support).

Це має багато переваг, особливо для невеликих команд. Інтеграція змін якнайшвидше може справді пришвидшити розробку. Зрештою, це усуває майже всю бюрократію постійних запитів на отримання та злиття — хоча тут передбачається більш активний процес спілкування з вашою командою все одно необхідне, "щоб не наступати один одному на ноги", і всі повинні завжди знати, над чим працють інші.

Однак це не найкращий спосіб організації розробки, оскільки він покладається на дисципліну та дійсно хороших розробників (SWE). Це справді чудове рішення для швидкого випуску продуктів або швидкого повторення існуючих проектів.

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

Проте потрібно зауважити, що така розробка передбачає запровадження методологій CI&#x20;

## Conclusions

Якщо коротко пояснити різницю у кількох схемах, то об'єднання функціональних гілок із dev виглядає у порівнянні із trunk наступним чином:&#x20;

<figure><img src="../../.gitbook/assets/image (19).png" alt=""><figcaption></figcaption></figure>

І найцікавіше, що VSTS від MS також використовує даний підхід до розробки і пригадують, що раніше також використовували стандартний підхід, але відмовилися від нього у зв'язку із тим, що підняли частоту релізів та синхронізували їх із спринтами ([Release Flow: How We Do Branching on the VSTS Team](https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/)).

<figure><img src="../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

## P.S. Mixed model

Вирішив об'єднати все у одну структурну схему, яка б поєднала хоча б умовно ресурси, середовища та контроль версій кодую, для прикладу тут застосовуватимуться ресурси Azure.  Так як ми не можемо собі дозволити утримувати одночасно ресурси у всіх середовищах, адже це значно збільшує витрати, можна застосуватися підхід, який носить назву "One environment with limited data access, one with production data access". Тобто у ньому ми маємо ресурси на проді, а от тест та дев середовища ділять їх між собою. Це видається якраз тим, що потрібно для нас, адже за цього налаштування, ресурси розгортається в двох середовищах: одне з обмеженим доступом до даних, а інше — з доступом до робочих даних. Це типове налаштування, якщо потрібно розділити середовища розробки та прод. Наприклад, команда працює в умовах організаційних обмежень, щоб зробити виробничі дані доступними в будь-якому середовищі, або можна відокремити роботу з розробки та прод роботу, не дублюючи дані більше, ніж потрібно, через високу вартість обслуговування.\
\
Перевагою цього налаштування є чіткий розподіл обов’язків і доступу між середовищами dev та prd . Іншою перевагою є менші накладні витрати на керування ресурсами порівняно зі сценарієм розгортання в кількох середовищах.\
\
Для цього підходу потрібен певний процес розробки та розгортання артефактів машинного навчання в робочих областях. Ще одна складність полягає в тому, що можуть знадобитися значні зусилля DE для керування даними, щоб зробити виробничі дані доступними для навчання в середовищі розробки. Однак це може вимагати відносно менше зусиль, ніж розгортання робочого процесу в одразу у кількох середовищах.\
\
Тому пропонується наступна схема, представлена нижче. Очікується, що для кожного клієнта в рамках його підписки буде розгорнуто ресурсну групу із необхідними комопенентами для клієнтського PRD середовища на якому також і буде тестуватися пілот (зокрема проводиться і тестування розгортання ресурсів за допомогою Terraform та деплой релізу черезу Azure DevOps Pipelines). Середовища із готовим продуктом поточного релізу для демо (PRD / Demo) та Test/Staging, для валідації функціональних змін у поточному релізі, так само як і dev, у якому ведеться основна активна розробка, знаходяться у робочій підписці та ресурсній групі із усіма необхідними компонентами. \
У якості запобіжників для чіткого розмежування релізів, функціоналу, розробки, тестування тощо слугує система контролю версій та управління Git репозиторієм.\


1. Main - гілка яка містить останній готовий реліз та позначена відповідним тегом актуального релізу.&#x20;
2. hotfix/.... - короткострокові гілки, створені для вирішення актуальних багів, що виникають на стороні клієнта АБО демо у поточному релізі.
3. customer/release АБО release/customer - код робочого релізу, що виконується на ресурсах клієнта. Версінування гілок по релізах на стороні клієнта також є необхідним, оскільки різні клієнти можуть бути на різних релізах продукту.
4. release - гілка, яка містить код, що має проганятися саме у тестовому середовищі, як такий, що майже готовий до релізу та потребує доопрацювання.
5. releasefixes/.... - гілки для виправлення багів, що виникають при тестуванні на етапі стейджингу перед поточним релізом.
6. dev - основна гілка розробки, у якій ведеться більшість роботи. Саме останні напрацювання з неї є основою для створення релізної гілки, яка за результатами успішного тестування може релізнутися та змерджитися із main. Тому тут міститься відносно стабільний код, який постійно перебуває у процесі розробки.&#x20;
7. feture/...., explore/...., refactoring/.... - так інші гілки відповідно до конвенції по неймінгу та за функціональним призначенням, що створені в рамках поточних завдань, юзер сторі під час розробки. В рамках активної розробки до них висуваються вимогу постійного оновлення змін із dev гілки для полегшення подальшого об'єднання.
8. staging/... - допоміжні гілки для проведення злиття гілок.

В ідеальному варіанті, для полегшення виконання даних процесів по злиттю має функціонувати декілька CI пайплайнів, що відповідно запускаються при відкритті PR у гілки dev, release та main. Таким чином на усіх етапах та у всіх середовищах мають відбуватися автоматизовані тести.

<figure><img src="https://ds-vsts.visualstudio.com/9bd9c8b9-9a32-4094-91e6-566176744bc4/_apis/wit/attachments/76908815-d012-4ba3-94cd-606ef5eaafdd?fileName=image.png" alt=""><figcaption></figcaption></figure>
